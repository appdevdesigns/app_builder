/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */
const ABQLCore = require("../../core/ql/ABQLCore.js");
const FilterComplex = require("../FilterComplex.js");
const RowUpdater = require("../RowUpdater.js");

class ABQL extends ABQLCore {
   // constructor(attributes, parameterDefinitions, prevOP, task, application) {
   //     super(attributes, parameterDefinitions, prevOP, task, application);
   // }

   ///
   /// Instance Methods
   ///

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      // var allColumns = row.getChildViews();
      // allColumns.shift(); // remove selector
      this.parameterDefinitions.forEach((pDef) => {
         // var col = allColumns.shift();
         var myID = this.uiID(id);
         this.ids = this.toIDs(myID);
         this.params = this.params || {};

         switch (pDef.type) {
            case "objectName":
               this.params[pDef.name] = $$(this.ids.objectname).getValue();
               break;

            case "objectConditions":
            case "objectValues":
               var uiCondition = $$(this.ids.condition);
               if (uiCondition) {
                  var condition = uiCondition.getValue();
                  if (condition && condition != "") {
                     this.params[pDef.name] = JSON.parse(condition);
                  }
               }
               break;
         }
      });
   }

   /*
    * @method toIDs()
    * generate a set of unique webix ids to use for our UI.
    * @param {string} myID
    *        the unique id generated by .uiID()
    */
   toIDs(myID) {
      return {
         condition: `${myID}_condition`,
         objectname: `${myID}_objname`,
         popup: `${myID}_popup`,
         select: `${myID}_select`,
         shorthand: `${myID}_shorthand`
      };
   }

   /**
    * @method uiAddParamForDef()
    * Add an operation parameter for each parameterDefinition we have defined.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParamForDef(pDef, id, ui) {
      // params are added to a .col[] definition.
      // if our ui isn't down to the current .col element, then drill down
      if (!ui.cols) {
         if (ui.rows) {
            for (var i = 0; i < ui.rows.length; i++) {
               if (ui.rows[i].cols) {
                  this.uiAddParamForDef(pDef, id, ui.rows[i]);
                  break;
               }
            }
         } else {
            throw new Error("provided ui is not able to add a parameter!");
         }
         return;
      }

      var paramUI = this.uiParamUI(pDef, id);

      if (paramUI) {
         // if we only have 1 param
         if (this.parameterDefinitions.length == 1) {
            ui.cols.push(paramUI);
         } else {
            // if we haven't already added a parameter
            if (ui.cols.length < 3) {
               // create a row stack of parameters:
               ui.cols.push({
                  rows: [paramUI]
               });
            } else {
               // add to the current stack of parameters
               ui.cols[2].rows.push(paramUI);
            }
         }
      }
   }

   /**
    * @method uiAddNext()
    * Add the next row selector for this operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddNext(id, ui) {
      var uiRow = this.uiNextRow(id);

      // if we have a next operation defined, then add on the ui definitions
      // for that operation:
      if (this.next) {
         this.next.uiAddParams(id, uiRow);
         ui.rows.push(uiRow);
         this.next.uiAddNext(id, ui);
      } else {
         // otherwise we just leave the selector:
         ui.rows.push(uiRow);
      }
   }

   /**
    * @method uiAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParams(id, ui) {
      this.parameterDefinitions.forEach((pDef) => {
         this.uiAddParamForDef(pDef, id, ui);
      });
   }

   /*
    * @method uiID()
    * generate a unique webix id for this operation.
    * @param {string} id
    *        the webix id of the base property.query holder
    */
   uiID(id) {
      if (this.prevOP) {
         return `${this.prevOP.uiID(id)}_${this.constructor.key}`;
      } else {
         return `${id}_${this.constructor.key}`;
      }
   }

   /*
    * uiXXX Operations:
    * are UI building operations that are performed BEFORE the webix UI
    * is generated.  They work by filling out a {ui} object definition
    * that webix will eventually create into the DOM.
    *
    * viewXXX Operations:
    * are UI building operations that are performed AFTER the webix UI
    * is generated. They work by adding in child views to an existing
    * DOM.
    */

   /**
    * @method uiNextRow()
    * return the webix UI definition for the next of UI chaining.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiNextRow(id) {
      var options = this.constructor.NextQLOps.map((op) => {
         return { id: op.key, value: op.label };
      });
      options.unshift({ id: 0, value: "choose next operation" });

      var myID = this.uiID(id);
      var ids = this.toIDs(myID);

      var uiRow = {
         cols: [
            { view: "spacer", width: this.constructor.uiIndentNext || 10 },
            {
               id: ids.select,
               view: "select",
               value: this.next ? this.next.constructor.key : 0,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     function resetValue() {
                        var select = $$(ids.select);
                        select.blockEvent();
                        select.setValue(oldValue);
                        select.unblockEvent();
                     }
                     if (newValue == oldValue) {
                        return;
                     }
                     var newOP = this.constructor.NextQLOps.find((op) => {
                        return op.key == newValue;
                     });
                     if (!newOP) {
                        resetValue();
                        return;
                     }

                     var thisRow = $$(ids.select).getParentView();
                     var thisQuery = thisRow.getParentView();

                     var addOP = () => {
                        if (newOP) {
                           var nextOP = new newOP(
                              {},
                              this,
                              this.task,
                              this.application
                           );
                           this.next = nextOP;
                           nextOP.viewAddParams(id, thisRow);
                           nextOP.viewAddNext(id, thisQuery);
                        }
                     };

                     // if there are rows after this one, then warn
                     // about changing
                     var allRows = thisQuery.getChildViews();
                     if (allRows.length - 1 > allRows.indexOf(thisRow)) {
                        webix.confirm({
                           title: "continue?",
                           text:
                              "changing this rule will reset any following rules.",
                           ok: "yes",
                           cancel: "no",
                           callback: (result) => {
                              if (result) {
                                 // remove the current additional Rows:
                                 var ir = allRows.length - 1;
                                 while (
                                    allRows[ir].config.id != thisRow.config.id
                                 ) {
                                    thisQuery.removeView(allRows[ir]);
                                    ir--;
                                 }

                                 // now remove the parameters
                                 var allCols = thisRow.getChildViews();
                                 var ic = allCols.length;
                                 while (ic > 1) {
                                    thisRow.removeView(allCols[ic - 1]);
                                    ic--;
                                 }

                                 addOP();
                              } else {
                                 resetValue();
                              }
                           }
                        });
                     } else {
                        addOP();
                     }
                  }
               }
            }
         ]
      };

      return uiRow;
   }

   /**
    * @method uiParamUI()
    * return the webix UI definition for the parameter entry of this current
    * operation.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiParamUI(pDef, id) {
      var myID = this.uiID(id);
      this.ids = this.toIDs(myID);
      var paramUI = null;

      // now add the parameter
      switch (pDef.type) {
         case "objectName":
            // an objectName parameter returns a select list of available
            // objects in this application.
            var options = this.application.objects().map((o) => {
               return { id: o.id, value: o.label };
            });
            paramUI = {
               id: this.ids.objectname,
               view: "select",
               value: this.objectID,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     this.params = this.params || {};
                     if (newValue != this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef);
                     }
                  }
               }
            };
            break;

         case "objectConditions":
            // objectConditions: returns a filter text summary, that when
            // clicked, pops up a Filter Entry Popup.
            // the actual value is stored in a hidden field.

            // we will create a new FilterComplex() object to use for our
            // filtering.
            // Our goal is to create a special filter entry for each avaiable
            // process data value that is available.
            // A filter entry needs to look like:
            // {
            //     id: `{string}`,      // A unique id selector for this filter
            //     name: `{string}`,    // the operation name displayed
            //     type, {obj}          // an object defining the editor to show
            //     fn: ()=>{}           // a function used for filtering elements
            // }
            //
            // In our filters, we are assigning filters to EACH field by the
            // field.id.  So the type definition needs to look like:
            // {
            //     "uniqueID of the field (field.id)" : {webixUI definition}
            // }

            var Filter = new FilterComplex(null, id);
            var hashFieldIDs = this.availableProcessDataFieldsHash();
            if (this.object) {
               Filter.fieldsLoad(this.object.fields(), this.object);
               // NOTE: this will create default filters based upon the
               // object fields() and their types

               // Now we need to add in the Process Data Fields:
               // for each Process Data Field that matches our same object
               var foundFields = Object.keys(hashFieldIDs)
                  .map((f) => {
                     return hashFieldIDs[f];
                  })
                  .filter((k) => {
                     return k.object && k.object.id == this.object.id;
                  });

               (foundFields || []).forEach((processField) => {
                  var type = {};
                  if (processField.field) {
                     type[processField.field.id] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  } else {
                     // if there is no .field, it is probably an embedded special field
                     // like: .uuid
                     var key = processField.key.split(".").pop();
                     type[key] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  }

                  // add an "equals" and "not equals" filter for each:
                  Filter.filterAdd([
                     {
                        id: `context_equals`,
                        name: `equals`,
                        type,
                        fn: (a, b) => {
                           return a == b;
                        }
                     },
                     {
                        id: `context_not_equal`,
                        name: `not equals`,
                        type,
                        fn: (a, b) => {
                           return a != b;
                        }
                     }
                  ]);
               });
            }

            // every time the Filter "saves" it's data, it emits this event:
            // take the given condition and store it in our hidden element.
            Filter.on("save", (condition) => {
               // @param {obj} condition an object describing the filter
               // condition.

               this.params = this.params || {};
               this.params[pDef.name] = condition;

               var shortHand = $$(this.ids.shorthand);
               console.log(Filter.toShortHand());
               shortHand.define({
                  label: Filter.toShortHand()
               });
               shortHand.refresh();

               // NOTE: the hidden element is a text field, so convert the
               // {condition object} => a string
               var condition = $$(this.ids.condition);
               condition.define({
                  value: JSON.stringify(this.params[pDef.name])
               });
               condition.refresh();
            });

            // create the initial condition value from our inputs.
            var initialCond = "";
            if (this.params && this.params[pDef.name]) {
               Filter.setValue(this.params[pDef.name]);
               initialCond = JSON.stringify(this.params[pDef.name]);
            }

            // what we show on the panel, is a text representation
            // of the current condition.
            var displayLabel = Filter.toShortHand();
            paramUI = {
               rows: [
                  {
                     id: this.ids.shorthand,
                     view: "label",
                     label: displayLabel,
                     on: {
                        onItemClick: function() {
                           Filter.popUp();
                        }
                     }
                  },
                  // have a hidden field to contain the condition
                  // value we will parse out later
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialCond,
                     hidden: true
                  }
               ]
            };
            break;

         case "objectValues":
            // objectValues : shows a condences textual representation of the
            // field => value changes.  Clicking on the text will show a popup
            // that allows you to add/remove additional field updates for
            // the current object.

            var initialCond = "";
            var Updater = new RowUpdater(null, myID);
            if (this.object) {
               Updater.objectLoad(this.object);
            }

            // NOTE: .setValue() must be called once the RowUpdater is already
            // displayed.  See the end of popUp() below:
            if (this.params && this.params[pDef.name]) {
               Updater.setValue(this.params[pDef.name]);
               initialCond = JSON.stringify(this.params[pDef.name]);
            }

            var popUp = () => {
               // show the RowUpdater in a popup:
               var ui = {
                  id: this.ids.popup,
                  view: "popup",
                  position: "center",
                  height: 500,
                  width: 1000,
                  body: {
                     rows: [
                        Updater.ui,
                        {
                           view: "button",
                           value: "Save",
                           click: () => {
                              this.params = this.params || {};
                              this.params[pDef.name] = Updater.getValue();
                              var sh = $$(this.ids.shorthand);
                              sh.define({
                                 label: JSON.stringify(this.params[pDef.name])
                              });
                              sh.refresh();

                              var cond = $$(this.ids.condition);
                              cond.define({
                                 value: JSON.stringify(this.params[pDef.name])
                              });
                              cond.refresh();

                              $$(this.ids.popup).hide();
                           }
                        }
                     ]
                  }
               };

               // create and show the popup
               this._myPopup = webix.ui(ui);
               this._myPopup.show();

               // NOTE: on a RowUpdater, the values need to be set
               // AFTER it is displayed:
               if (this.params && this.params[pDef.name]) {
                  Updater.setValue(this.params[pDef.name]);
               }
            };
            paramUI = {
               rows: [
                  // the textual shorthand for these values
                  {
                     id: this.ids.shorthand,
                     view: "label",
                     label: initialCond,
                     on: {
                        onItemClick: function() {
                           popUp();
                        }
                     }
                  },
                  // the hidden field that contains the results
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialCond,
                     hidden: true
                  }
               ]
            };
            break;
      }

      return paramUI;
   }

   /**
    * @method viewAddNext()
    * Add the next selector row After this Operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} topView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the top container that is adding a new
    *        row for each operation.
    */
   viewAddNext(id, topView) {
      var uiRow = this.uiNextRow(id);
      topView.addView(uiRow);
   }

   /**
    * @method viewAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} rowView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the ROW that the parameters are added to
    */
   viewAddParams(id, rowView) {
      var params = [];
      this.parameterDefinitions.forEach((pDef) => {
         // get the definition from .uiParamUI()
         params.push(this.uiParamUI(pDef, id));
      });
      var toInsert = null;
      // stack parameters in a row if there are more than 1
      if (params.length > 1) {
         toInsert = {
            rows: params
         };
      } else {
         toInsert = params.pop();
      }
      if (toInsert) {
         rowView.addView(toInsert);
      }
   }

   ////
   //// QueryString Parser routines:
   ////

   /*
     * parseQuery()
     * check the given query string input and see if this object is the
     * starting object.
     * @param {string} query
     *			 the entered query string operation.
     * @return {bool}
     * /
    static parseQuery(query) {
        // we want to see if the beginning of this query matches our
        // option_begin string.
        var begQuery = query;
        if (query.length > this.option_begin.length) {
            begQuery = query.slice(0, this.option_begin.length);
        }
        if (this.option_begin.indexOf(begQuery) == 0) {
            return true;
        }
        return false;
    }



    /// ABApplication data methods

    tabComplete() {
        if (this._suggestions) {
            // if our begin tag is  present in _suggestions
            if (
                this._suggestions.indexOf(this.constructor.option_begin) != -1
            ) {
                // this is probably finishing out our command:
                this.currQuery = this._suggestions;
            } else {
                // we are suggesting a parameter value:
                this.currQuery = `${this.constructor.option_begin}${this._suggestions}`;
            }

            // now make sure we do another refresh to get another
            // suggestion.
            this.fromQuery(this.currQuery);
        }
    }

    paramsToString() {
        var strs = [];
        this.parameterDefinitions.forEach((pDef) => {
            strs.push(this.params[pDef.name]);
            // switch (pDef.type) {
            //     case "objectName":
            //         strs.push(this.params[pDef.name]);
            //         break;
            // }
        });

        return strs.join(",");
    }

    /**
     * @method toObj()
     *
     * properly compile the current state of this ABView instance
     * into the values needed for saving to the DB.
     *
     * @return {json}
     * /
    toQuery() {
        if (this.entryComplete) {
            return `${this.prevOP ? this.prevOP.toQuery() : ""}${
                this.constructor.option_begin
            }${this.params ? this.paramsToString() : ""})`;
        } else {
            return `${this.prevOP ? this.prevOP.toQuery() : ""}${
                this.currQuery ? this.currQuery : ""
            }`;
        }
    }

    fromQuery(queryString) {
        var results = this.constructor.regEx.exec(queryString);
        if (results) {
            this.entryComplete = true;
            this.queryValid = true;
            this.params = {};

            if (this.paramsValid(results[1])) {
                // now progress on to any next operations:
                var newQuery = queryString.replace(this.constructor.regEx, "");
                var matchingOPs = [];
                this.constructor.NextQLOps.forEach((OP) => {
                    if (OP.parseQuery(newQuery)) {
                        matchingOPs.push(OP);
                    }
                });
                if (matchingOPs.length == 1) {
                    // exact match, so add next:
                    var qlOP = new matchingOPs[0](
                        {},
                        this,
                        this.task,
                        this.application
                    );
                    qlOP.fromQuery(newQuery);
                    this.next = qlOP;
                }

                // if there were no matching OPs, then they typed an error:
                if (matchingOPs.length == 0) {
                    this.queryValid = false;
                }
            } else {
                // I don't recoginze these params!
                this.queryValid = false;
                this._suggestions = " ! Invalid Params !";
            }
        } else {
            this.currQuery = queryString;
            this.queryValid = true; // assume true then set to false later
            this._suggestions = null;

            // calculate the processing of our command + params:
            // if we have finished our begining
            if (this.currQuery.indexOf(this.constructor.option_begin) == 0) {
                var param = this.currQuery.slice(
                    this.constructor.option_begin.length
                );

                this.paramsFromQuery(param);
            } else {
                // else they need to finish the beginning
                this._suggestions = this.constructor.option_begin;
            }

            // if we didn't have any suggestions, then what they typed
            // doesn't match, so remove the last character:
            if (!this._suggestions) {
                this.currQuery = this.currQuery.slice(0, -1);
                this.queryValid = false;
                this._suggestions = null;

                // try to regenerate the suggestions again:
                var param = this.currQuery.slice(
                    this.constructor.option_begin.length
                );

                this.paramsFromQuery(param);
            }
        }
    }

    firstOP() {
        if (!this.prevOP) {
            return this;
        } else {
            return this.prevOP.firstOP();
        }
    }

    lastOP() {
        if (!this.entryComplete) {
            return this;
        } else {
            // now figure out which of our nextOps are being used.
            if (this.next) {
                return this.next.lastOP();
            } else {
                // we haven't specified a next OP, so we are still up.
                return this;
            }
        }
    }

    paramPull(paramDef, queryString) {
        var result = { param: queryString, balance: 0 };
        if (queryString.length > 0) {
            switch (paramDef.type) {
                case "objectName":
                    // define a lexer for objectNames
                    var lexerObjectName = moo.compile({
                        comma: { match: "," },
                        name: {
                            match: /"(?:\\["\\]|[^\n"\\])*"/
                            // value: (s) => s.slice(1, -1)
                        },
                        WS: /[ \t]+/,
                        currKey: moo.error
                    });
                    lexerObjectName.reset(queryString);
                    var name = "";
                    var foundObj = null;
                    var token = lexerObjectName.next();

                    if (token) {
                        // if this is the 2nd time through, might
                        // begin with a ','
                        while (token.type == "comma") {
                            token = lexerObjectName.next();
                        }

                        // pull the parameter from the current queryString
                        if (["name", "currKey"].indexOf(token.type) != -1) {
                            name = token.value;
                        }
                        result.param = name;
                    }

                    break;

                case "objectConditions":
                case "objectValues":
                    // define a lexer for objectConditions
                    // the goal of this lexer is to achieve json balance
                    // ( equal # of { & }) while reaching an end condition:
                    var lexerObjectCond = moo.compile({
                        comma: { match: "," },
                        colon: { match: ":" },
                        lbrace: { match: "{" },
                        rbrace: { match: "}" },
                        rparen: { match: ")" },
                        keyval: {
                            match: /"(?:\\["\\]|[^\n"\\])*"/
                            // value: (s) => s.slice(1, -1)
                        },
                        WS: /[ \t]+/,
                        currKey: moo.error
                    });
                    lexerObjectCond.reset(queryString);
                    var balance = 0;
                    var foundObj = null;
                    var token = lexerObjectCond.next();
                    var stop = false;
                    var param = "";
                    while (token && !stop) {
                        if (token.type == "lbrace") {
                            balance++;
                        }
                        if (token.type == "rbrace") {
                            balance--;
                        }

                        // check for stop condition:
                        // when balance is achieved and we find a ","
                        if (balance == 0) {
                            if (token.type == "comma") {
                                stop = true;
                            }
                        }

                        if (!stop) {
                            param += token.value;
                            token = lexerObjectCond.next();
                        }
                    }
                    result.param = param;
                    result.balance = balance;
                    break;
            }
        }

        return result;
    }

    suggestionComplete() {
        var params = [];
        this.parameterDefinitions.forEach((pDef) => {
            params.push(this.params[pDef.name]);
        });
        return `${this.constructor.option_begin}${params.join(",")})`;
    }

    /**
     * @method paramsFromQuery()
     * take the given queryString value and see if it matches our
     * possible parameter values.
     * we update ._suggestions based upon the current param state.
     * @param {string} queryString
     * /
    paramsFromQuery(queryString) {
        var keepGoing = true;
        var current = queryString;

        // for each of our parameters,
        this.parameterDefinitions.forEach((pDef) => {
            if (!keepGoing) return;

            // pull the current param
            var pullResult = this.paramPull(pDef, current);
            current = current.replace(pullResult.param, "");

            // if this param is NOT valid
            if (!this.paramIsValid(pDef, pullResult)) {
                // don't keep going after this
                keepGoing = false;

                // offer suggestions for this param
                switch (pDef.type) {
                    case "objectName":
                        // return suggestions for our parameters
                        var suggestions = [];
                        var objects = this.application.objects((o) => {
                            var quotedLabel = `"${o.label}"`;
                            return (
                                pullResult.param.length == 0 ||
                                quotedLabel.indexOf(pullResult.param) == 0
                            );
                        });
                        objects.forEach((o) => {
                            suggestions.push(`"${o.label}"`);
                        });
                        this._suggestions = suggestions.join("\n");
                        break;

                    case "objectConditions":
                    case "objectValues":
                        var paramComplete = false;
                        var paramObj = null;
                        try {
                            paramObj = JSON.parse(pullResult.param);
                            paramComplete = true;
                        } catch (e) {}

                        if (paramComplete) {
                            this.paramObj = paramObj;
                            this.params[pDef.name] = pullResult.param;
                            // this.entryComplete = true;
                            this._suggestions = this.suggestionComplete();
                        } else {
                            // define a lexer to help us parse through the provided cond string
                            var lexer = moo.states({
                                start: {
                                    lbrace: { match: "{", push: "key" }
                                },
                                key: {
                                    colon: { match: ":", push: "value" },
                                    rparen: { match: ")", pop: true },
                                    key: {
                                        match: /"(?:\\["\\]|[^\n"\\])*"/
                                        // value: (s) => s.slice(1, -1)
                                    },
                                    WS: /[ \t]+/,
                                    currKey: moo.error
                                },
                                value: {
                                    // lbrace: { match: "{", push: "complexValue" },
                                    rbrace: { match: "}", pop: true },
                                    valueContext: {
                                        match: /"\$context\((?:\\["\\]|[^\n"\\])*?\)"/
                                    },
                                    value: {
                                        match: /"(?:\\["\\]|[^\n"\\])*"/
                                    },
                                    comma: { match: ",", pop: true },
                                    currVal: moo.error
                                }
                            });

                            // now follow our state, to figure out if we are entering a
                            // key, or a value, and then figure out how to offer suggestions
                            // based upon what they are entering now:
                            var state = "start";
                            lexer.reset(pullResult.param);
                            var token = lexer.next();
                            var lastToken = null;
                            var lastKey = null;
                            while (token) {
                                switch (state) {
                                    case "start":
                                        if (token.type == "lbrace") {
                                            state = "key";
                                        }
                                        break;
                                    case "key":
                                        if (token.type == "colon") {
                                            state = "value";
                                        }
                                        if (token.type == "key") {
                                            lastKey = token.value;
                                        }
                                        break;

                                    case "value":
                                        if (token.type == "comma") {
                                            state = "key";
                                        }
                                        break;
                                }
                                lastToken = token;
                                token = lexer.next();
                            }

                            // by this point, we have ended on a state, and can figure out
                            // what to suggest:
                            switch (state) {
                                case "start":
                                    // if we ended here, then we didn't even have our first {
                                    this._suggestions = "{cond}";
                                    break;

                                case "key":
                                    // we are entering a Key, so suggest the available fields
                                    // from this object
                                    var currKey = "";
                                    var types = ["key", "currKey"];
                                    if (types.indexOf(lastToken.type) != -1) {
                                        currKey = lastToken.value;
                                    }
                                    this._suggestions = this.fieldList(currKey);

                                    // if we end up with ._suggestions == currKey
                                    // then the key is complete, and we need to now enter ":"
                                    if (this._suggestions == currKey) {
                                        this._suggestions = ":";
                                    }
                                    break;

                                case "value":
                                    // entering a value, decide what to suggest based on what
                                    // the current key/field we are on:
                                    var currValue = "";
                                    var types = [
                                        "value",
                                        "valueContext",
                                        "currVal"
                                    ];
                                    if (types.indexOf(lastToken.type) != -1) {
                                        currValue = lastToken.value;
                                    }
                                    this._suggestions = this.valueList(
                                        lastKey,
                                        currValue
                                    );
                                    break;
                            }
                        }

                        break;
                }
            }
        });

        if (keepGoing) {
            // none of our params were invalid, so just suggest to complete our
            this._suggestions = this.suggestionComplete();
        }
    }

    paramIsValid(paramDef, pullResult) {
        var isValid = true;
        this.params = this.params || {};
        switch (paramDef.type) {
            case "objectName":
                // verify it is valid
                var param = pullResult.param;
                var foundObj = null;
                if (param) {
                    // see if we find a Matching Object
                    foundObj = this.application.objects((o) => {
                        var quotedLabel = `"${o.label}"`;
                        return (
                            param.length == 0 || quotedLabel.indexOf(param) == 0
                        );
                    })[0];
                    if (foundObj) {
                        this.params[paramDef.name] = param;
                        // it is NOT valid unless it is an exact match:
                        if (`"${foundObj.label}"` != param) {
                            isValid = false;
                        }
                    }
                }
                isValid = isValid && param.length > 0 && foundObj;
                break;

            case "objectConditions":
            case "objectValues":
                if (pullResult.balance == 0) {
                    this.params[paramDef.name] = pullResult.param;
                }
                isValid =
                    isValid &&
                    pullResult.balance == 0 &&
                    pullResult.param.length > 0;
                break;
        }

        return isValid;
    }
    /**
     * @method paramsValid()
     * parse through the given text and see if our defined parameters
     * can be properly represented.
     * @param {string} queryString
     *        the current value of the text that is the parameter(s) to our
     *        function.
     * @return {bool}
     *         true : if every parameter parses
     *         false: otherwise
     * /
    paramsValid(queryString) {
        // queryString represents the full text parameters. Might be > 1 params

        var current = queryString;
        var isValid = true; // so optimistic.

        // for each of our defined parameters
        this.parameterDefinitions.forEach((pDef) => {
            var pullResult = this.paramPull(pDef, current);
            current = current.replace(pullResult.param, "");
            isValid = isValid && this.paramIsValid(pDef, pullResult);
        });

        return isValid;
    }

    suggestions() {
        if (this.entryComplete) {
            // return suggestions for next operations.
            var suggestions = [];

            this.constructor.NextQLOps.forEach((OP) => {
                suggestions.push(OP.option);
            });
            return suggestions.join("\n");
        } else {
            return this._suggestions;
        }
    }
    */
}

module.exports = ABQL;
